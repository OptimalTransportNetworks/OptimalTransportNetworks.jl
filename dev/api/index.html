<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Optimal Transport Networks Documentation</title><meta name="title" content="API · Optimal Transport Networks Documentation"/><meta property="og:title" content="API · Optimal Transport Networks Documentation"/><meta property="twitter:title" content="API · Optimal Transport Networks Documentation"/><meta name="description" content="Documentation for Optimal Transport Networks Documentation."/><meta property="og:description" content="Documentation for Optimal Transport Networks Documentation."/><meta property="twitter:description" content="Documentation for Optimal Transport Networks Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Optimal Transport Networks Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><ul><li><a href="#OptimalTransportNetworks.add_node-NTuple{5, Any}"><code>OptimalTransportNetworks.add_node</code></a></li><li><a href="#OptimalTransportNetworks.annealing-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.annealing</code></a></li><li><a href="#OptimalTransportNetworks.apply_geography-Tuple{Any, Any}"><code>OptimalTransportNetworks.apply_geography</code></a></li><li><a href="#OptimalTransportNetworks.create_graph"><code>OptimalTransportNetworks.create_graph</code></a></li><li><a href="#OptimalTransportNetworks.find_node-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.find_node</code></a></li><li><a href="#OptimalTransportNetworks.init_parameters-Tuple{}"><code>OptimalTransportNetworks.init_parameters</code></a></li><li><a href="#OptimalTransportNetworks.optimal_network-Tuple{Any, Any}"><code>OptimalTransportNetworks.optimal_network</code></a></li><li><a href="#OptimalTransportNetworks.plot_graph"><code>OptimalTransportNetworks.plot_graph</code></a></li><li><a href="#OptimalTransportNetworks.remove_node-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.remove_node</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.add_node-NTuple{5, Any}" href="#OptimalTransportNetworks.add_node-NTuple{5, Any}"><code>OptimalTransportNetworks.add_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_node(param, graph, x, y, neighbors) -&gt; Dict, NamedTuple</code></pre><p>Add a node in position (x,y) and list of neighbors. The new node is given an index J+1.</p><p><strong>Arguments</strong></p><ul><li><code>param::Dict</code>: Dict that contains the model&#39;s parameters, or <code>nothing</code> to only update graph</li><li><code>graph::NamedTuple</code>: Named tuple that contains the underlying graph (created by create_graph())</li><li><code>x::Float64</code>: x coordinate of the new node (any real number)</li><li><code>y::Float64</code>: y coordinate of the new node (any real number)</li><li><code>neighbors::Vector{Int64}</code>: Vector of nodes to which it is connected (1 x n list of node indices between 1 and J, where n is an arbitrary # of neighbors) </li></ul><p>The cost matrices <code>delta_tau</code> and <code>delta_i</code> are parametrized as a function of Euclidean distance between nodes.</p><p>Returns the updated <code>graph</code> and <code>param</code> objects (<code>param</code> is affected too because the variable <code>Zjn</code>, <code>Lj</code>, <code>Hj</code> and others are reset to a uniform dist.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/nodes.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.annealing-Tuple{Any, Any, Any}" href="#OptimalTransportNetworks.annealing-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.annealing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">annealing(param, graph, I0; kwargs...)</code></pre><p>Runs the simulated annealing method starting from network <code>I0</code>. Only sensible if <code>param[:gamma] &gt; param[:beta]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>param</code>: Dict that contains the model&#39;s parameters</li><li><code>graph</code>: Named tuple that contains the underlying graph </li><li><code>I0</code>: (optional) provides the initial guess for the iterations</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>perturbation_method::String=&quot;random rebranching&quot;</code>: Method to be used to perturbate the network    (random is purely random, works horribly; shake applies a gaussian blur    along a random direction, works alright; rebranching (default) is the algorithm    described in Appendix A.4 in the paper, works nicely )</li><li><code>preserve_central_symmetry::Bool=false</code>: Only applies to shake method</li><li><code>preserve_vertical_symmetry::Bool=false</code>: Only applies to shake method</li><li><code>preserve_horizontal_symmetry::Bool=false</code>: Only applies to shake method</li><li><code>smoothing_radius::Float64=0.25</code>: Parameters of the Gaussian blur</li><li><code>mu_perturbation::Float64=log(0.3)</code>: Parameters of the Gaussian blur</li><li><code>sigma_perturbation::Float64=0.05</code>: Parameters of the Gaussian blur</li><li><code>display::Bool</code>: Display the graph in each iteration as we go</li><li><code>t_start::Float64=100</code>: Initial temperature</li><li><code>t_end::Float64=1</code>: Final temperature</li><li><code>t_step::Float64=0.9</code>: Speed of cooling</li><li><code>num_deepening::Int64=4</code>: Number of FOC iterations between candidate draws</li><li><code>num_random_perturbations::Int64=1</code>: Number of links to be randomly affected (&#39;random&#39; and &#39;random rebranching&#39; only)</li><li><code>Iu::Matrix{Float64}=Inf * ones(J, J)</code>: J x J matrix of upper bounds on network infrastructure Ijk</li><li><code>Il::Matrix{Float64}=zeros(J, J)</code>: J x J matrix of lower bounds on network infrastructure Ijk</li><li><code>model::Function</code>: For custom models =&gt; a function that taks an optimizer and an &#39;auxdata&#39; structure as created by create_auxdata() as input and returns a fully parameterized JuMP model</li><li><code>final_model::JuMPModel</code>: Alternatively: a readily parameterized JuMP model to be used (from <code>optimal_network()</code>)</li><li><code>recover_allocation::Function</code>: The <code>recover_allocation()</code> function corresponding to either <code>model</code> or <code>final_model</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Nonconvex case, disabling automatic annealing
param = init_parameters(annealing = false, gamma = 2)
param, graph = create_graph(param)
param[:Zjn][61] = 10.0
result = optimal_network(param, graph)

# Run annealing
results_annealing = annealing(param, graph, result[:Ijk])

# Comparison
plot_graph(graph, result[:Ijk])
plot_graph(graph, result_annealing[:Ijk])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/annealing.jl#L2-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.apply_geography-Tuple{Any, Any}" href="#OptimalTransportNetworks.apply_geography-Tuple{Any, Any}"><code>OptimalTransportNetworks.apply_geography</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_geography(graph, geography; kwargs...) -&gt; updated_graph</code></pre><p>Update the network building costs of a graph based on geographical features and remove edges impeded by geographical barriers.  Aversion to altitude changes rescales building infrastructure costs <code>delta_i</code> by (see also user manual to MATLAB toolbox):</p><p><code>1 + alpha_up * max(0, Z2-Z1)^beta_up + alpha_down * max(0, Z1-Z2)^beta_down</code></p><p>and similarly for graph traversal costs <code>delta_tau</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>graph::NamedTuple</code>: The network graph to which the geographical features will be applied.</p></li><li><p><code>geography::NamedTuple</code>: A named tuple representing the geographical features, with the following fields:</p><ul><li><p><code>z::Vector{Float64}</code>: A J x 1 vector containing the z-coordinate (elevation) for each node, or <code>nothing</code> if no elevation data.</p></li><li><p><code>z_is_friction::Bool</code>: (Optional) logical value indicate that <code>z</code> represents friction rather than elevation. In that case, the measure of building cost is the average friction of the two nodes mean(Z1,Z2) rather than the difference Z2-Z1.</p></li><li><p><code>obstacles::Matrix{Int64}</code>: An Nobs x 2 matrix specifying (i, j) pairs of nodes that are connected by obstacles, where Nobs is the number of obstacles, or <code>nothing</code> if no obstacles.</p></li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>across_obstacle_delta_i::Float64=Inf</code>: Rescaling parameter for building cost that crosses an obstacle.</li><li><code>along_obstacle_delta_i::Float64=Inf</code>: Rescaling parameter for building cost that goes along an obstacle.</li><li><code>across_obstacle_delta_tau::Float64=Inf</code>: Rescaling parameter for transport cost that crosses an obstacle.</li><li><code>along_obstacle_delta_tau::Float64=Inf</code>: Rescaling parameter for transport cost that goes along an obstacle.</li><li><code>alpha_up_i::Float64=0</code>: Building cost scale parameter for roads that go up in elevation.</li><li><code>beta_up_i::Float64=1</code>: Building cost elasticity parameter for roads that go up in elevation.</li><li><code>alpha_up_tau::Float64=0</code>: Transport cost scale parameter for roads that go up in elevation.</li><li><code>beta_up_tau::Float64=1</code>: Transport cost elasticity parameter for roads that go up in elevation.</li><li><code>alpha_down_i::Float64=0</code>: Building cost scale parameter for roads that go down in elevation.</li><li><code>beta_down_i::Float64=1</code>: Building cost elasticity parameter for roads that go down in elevation.</li><li><code>alpha_down_tau::Float64=0</code>: Transport cost scale parameter for roads that go down in elevation.</li><li><code>beta_down_tau::Float64=1</code>: Transport cost elasticity parameter for roads that go down in elevation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">param, graph = create_graph(init_parameters())
geography = (z = rand(graph.J), obstacles = [1 15; 70 72])
updated_graph = apply_geography(graph, geography)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/apply_geography.jl#L2-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.create_graph" href="#OptimalTransportNetworks.create_graph"><code>OptimalTransportNetworks.create_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_graph(param, w = 11, h = 11; type = &quot;map&quot;, kwargs...) -&gt; Dict, NamedTuple</code></pre><p>Initialize the underlying graph, population and productivity parameters.</p><p><strong>Arguments</strong></p><ul><li><code>param::Dict</code>: Structure that contains the model parameters</li><li><code>w::Int64=11</code>: Number of nodes along the width of the underlying graph (integer)  </li><li><code>h::Int64=11</code>: Number of nodes along the height of the underlying graph (integer, odd if triangle)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>type::String=&quot;map&quot;</code>: Either &quot;map&quot;, &quot;square&quot;, &quot;triangle&quot;, or &quot;custom&quot; </li><li><code>omega::Vector{Float64}</code>: Vector of Pareto weights for each node or region in partial mobility case (default ones(J or nregions))</li><li><code>Zjn::Matrix{Float64}</code>: J x N matrix of producties per node (j = 1:J) and good (n = 1:N) (default ones(J, N))</li><li><code>adjacency::BitMatrix</code>: J x J Adjacency matrix (only used for custom network)</li><li><code>x::Vector{Float64}</code>: x coordinate (longitude) of each node (only used for custom network)</li><li><code>y::Vector{Float64}</code>: y coordinate (latitude) of each node (only used for custom network)</li><li><code>nregions::Int64</code>: Number of regions (only for partial mobility)</li><li><code>region::Vector{Int64}</code>: Vector indicating region of each location (only for partial mobility)</li><li><code>Lj::Vector{Float64}</code>: Vector of popultions in each node (j = 1:J) (only for no mobility)</li><li><code>Lr::Vector{Float64}</code>: Vector of popultions in each region (r = 1:nregions) (only for partial mobility)</li><li><code>Hj::Vector{Float64}</code>: Vector of immobile good in each node (j = 1:J) (e.g. housing, default ones(J))</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">param, graph = create_graph(init_parameters())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/create_graph.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.find_node-Tuple{Any, Any, Any}" href="#OptimalTransportNetworks.find_node-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.find_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_node(graph, x, y) -&gt; Int64</code></pre><p>Returns the index of the node closest to the coordinates (x,y) on the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::NamedTuple</code>: structure that contains the underlying graph</li><li><code>x::Float64</code>: x coordinate on the graph (between 1 and w)</li><li><code>y::Float64</code>: y coordinate on the graph (between 1 and h)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/nodes.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.init_parameters-Tuple{}" href="#OptimalTransportNetworks.init_parameters-Tuple{}"><code>OptimalTransportNetworks.init_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_parameters(; kwargs...) -&gt; Dict</code></pre><p>Returns a <code>param</code> dict with the model parameters.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alpha::Float64=0.5</code>: Cobb-Douglas coefficient on final good c^alpha * h^(1-alpha)</li><li><code>beta::Float64=1</code>: Parameter governing congestion in transport cost</li><li><code>gamma::Float64=1</code>: Elasticity of transport cost relative to infrastructure</li><li><code>K::Float64=1</code>: Amount of concrete/asphalt</li><li><code>sigma::Float64=5</code>: Elasticity of substitution across goods (CES)</li><li><code>rho::Float64=2</code>: Curvature in utility (c^alpha * h^(1-alpha))^(1-rho)/(1-rho)</li><li><code>a::Float64=0.8</code>: Curvature of the production function L^alpha</li><li><code>m::Vector{Float64}=ones(N,1)</code>: Vector of weights Nx1 in the cross congestion cost function</li><li><code>N::Int64=1</code>: Number of goods</li><li><code>nu::Float64=1</code>: Elasticity of substitution b/w goods in transport costs if cross-good congestion</li><li><code>labor_mobility::Any=false</code>: Switch for labor mobility (true/false or &#39;partial&#39;)</li><li><code>cross_good_congestion::Bool=false</code>: Switch for cross-good congestion</li><li><code>annealing::Bool=true</code>: Switch for the use of annealing at the end of iterations (only if gamma &gt; beta)</li><li><code>verbose::Bool=true</code>: Switch to turn on/off text output (from Ipopt or other optimizers)</li><li><code>duality::Bool=true</code>: Switch to turn on/off duality whenever available</li><li><code>warm_start::Bool=false</code>: Use the previous solution as a warm start for the next iteration</li><li><code>kappa_tol::Float64=1e-7</code>: Tolerance for convergence of road capacities κ</li><li><code>kappa_min::Float64=1e-5</code>: Minimum value for road capacities κ</li><li><code>kappa_min_iter::Int64=20</code>: Minimum number of iterations</li><li><code>kappa_max_iter::Int64=200</code>: Maximum number of iterations</li><li><code>optimizer_attr::Dict</code>: Dict of attributes passed to the optimizer (e.g. <code>Dict(:tol =&gt; 1e-5)</code>)</li><li><code>model_attr::Dict</code>: Dict of tuples (length 2) passed to the model (e.g. <code>Dict(:backend =&gt; (MOI.AutomaticDifferentiationBackend(), MathOptSymbolicAD.DefaultBackend()))</code> to use Symbolic AD)</li><li><code>model::Function</code>: For custom models =&gt; a function that taks an optimizer and an &#39;auxdata&#39; structure as created by create_auxdata() as input and returns a fully parameterized JuMP model</li><li><code>recover_allocation::Function</code>: For custom models =&gt; a function that takes a solution and &#39;auxdata&#39; structure as input and returns the allocation variables. In particular, it should return a dict with symbol keys returning at least objects :welfare =&gt; scalar welfare measure, :Pjn =&gt; prices, :PCj =&gt; aggregate condumption, and :Qjkn =&gt; flows. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">param = init_parameters(labor_mobility = true, K = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/init_parameters.jl#L7-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.optimal_network-Tuple{Any, Any}" href="#OptimalTransportNetworks.optimal_network-Tuple{Any, Any}"><code>OptimalTransportNetworks.optimal_network</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimal_network(param, graph; I0=nothing, Il=nothing, Iu=nothing, 
                verbose=false, return_model=0) -&gt; Dict</code></pre><p>Solve for the optimal network by solving the inner problem and the outer problem by iterating over the FOCs.</p><p><strong>Arguments</strong></p><ul><li><code>param::Dict</code>: Dict that contains the model&#39;s parameters</li><li><code>graph::NamedTuple</code>: Named tuple that contains the underlying graph (created by <code>create_graph()</code> function)</li><li><code>I0::Matrix{Float64}</code>: (Optional) J x J matrix providing the initial guess for the iterations </li><li><code>Il::Matrix{Float64}</code>: (Optional) J x J matrix providing exogenous lower bound on infrastructure levels</li><li><code>Iu::Matrix{Float64}</code>: (Optional) J x J matrix providing exogenous upper bound on infrastructure levels</li><li><code>verbose::Bool</code>: (Optional) tell IPOPT to display results</li><li><code>return_model::Int=0</code>: (Optional) return the JuMP model and corresponding <code>recover_allocation()</code> function: 1 just returns these before solving the model, while 2 solves the model + optimal network and returns the two alongside the results. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">param = init_parameters()
param, graph = create_graph(param)
param[:Zjn][61] = 10.0
result = optimal_network(param, graph)
plot_graph(graph, result[:Ijk])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/optimal_network.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.plot_graph" href="#OptimalTransportNetworks.plot_graph"><code>OptimalTransportNetworks.plot_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_graph(graph, edges = nothing; kwargs...) -&gt; Plots.Plot</code></pre><p>Plot a graph visualization with various styling options.</p><p><strong>Arguments</strong></p><ul><li><code>graph::NamedTuple</code>: The network graph (created with <code>create_graph()</code>)</li><li><code>edges::Matrix{Float64}=nothing</code>: Matrix of edge weights (J x J)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>grid::Bool=false</code>: Show gridlines </li><li><code>axis::Tuple=([], false)</code>: Axis ticks and labels (see Plots.jl docs, default disable axis)</li><li><code>margin::Real=-30mm</code>: Margin around plot </li><li><code>map::Vector=nothing</code>: Values mapped to graph for background heatmap</li><li><code>map_color::Symbol=:YlOrBr_4</code>: Colorscale for background heatmap</li><li><code>mesh::Bool=false</code>: Show mesh lines between nodes</li><li><code>mesh_color::Symbol=:grey90</code>: Color for mesh lines </li><li><code>mesh_style::Symbol=:dash</code>: Linestyle for mesh lines</li><li><code>mesh_transparency::Real=1</code>: Opacity for mesh lines</li><li><code>edges::Bool=true</code>: Show edges between nodes</li><li><code>edge_color::Symbol=:blue</code>: Edge color or color gradient</li><li><code>edge_scaling::Bool=false</code>: Size edges based on raw values</li><li><code>edge_transparency::Union{Bool,Real}=true</code>: Transparency for edges</li><li><code>edge_min::Real</code>: Minimum edge value for scaling</li><li><code>edge_max::Real</code>: Maximum edge value for scaling  </li><li><code>edge_min_thickness::Real=0.1</code>: Minimum thickness for edges</li><li><code>edge_max_thickness::Real=2</code>: Maximum thickness for edges</li><li><code>arrows::Bool=false</code>: Show arrowheads on edges </li><li><code>arrow_scale::Real=1</code>: Scaling factor for arrowheads</li><li><code>arrow_style::String=&quot;long&quot;</code>: Style of arrowheads (&quot;long&quot; or &quot;thin&quot;)</li><li><code>nodes::Bool=true</code>: Show nodes</li><li><code>node_sizes::Vector=ones(J)</code>: Sizes for nodes</li><li><code>node_sizes_scale::Real=75</code>: Overall scaling for node sizes</li><li><code>node_shades::Vector=nothing</code>: Shades mapped to nodes</li><li><code>node_color::Symbol=:purple</code>: Node color or color gradient </li><li><code>node_stroke_width::Real=0</code>: Stroke width for node outlines</li><li><code>node_stroke_color::Symbol=nothing</code>: Stroke color for node outlines </li><li><code>geography::NamedTuple=nothing</code>: Named tuple with geography data, see also <code>apply_geography()</code></li><li><code>obstacles::Bool=false</code>: Show obstacles from geography</li><li><code>obstacle_color::Symbol=:black</code>: Color for obstacles</li><li><code>obstacle_thickness::Symbol=3</code>: Thickness for obstacles</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">param = init_parameters()
param, graph = create_graph(param)
param[:Zjn][51] = 10.0
result = optimal_network(param, graph)
plot_graph(graph, result[:Ijk])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/plot_graph.jl#L6-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalTransportNetworks.remove_node-Tuple{Any, Any, Any}" href="#OptimalTransportNetworks.remove_node-Tuple{Any, Any, Any}"><code>OptimalTransportNetworks.remove_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_node(param, graph, i) -&gt; updated_param, updated_graph</code></pre><p>Removes node i from the graph.</p><p><strong>Arguments</strong></p><ul><li><code>param::Dict</code>: structure that contains the model&#39;s parameters, or <code>nothing</code> to only update graph</li><li><code>graph::NamedTuple</code>: structure that contains the underlying graph (created by create_graph())</li><li><code>i::Int64</code>: index of the mode to be removed (integer between 1 and graph.J)</li></ul><p>Returns the updated graph and param objects (param is affected too because the variable Zjn, Lj, Hj and others are changed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebKrantz/OptimalTransportNetworks.jl/blob/b914dc5f0bf2ec5d86bd47f46ab566d29ca458a5/src/main/nodes.jl#L123-L134">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 17 March 2024 22:29">Sunday 17 March 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
